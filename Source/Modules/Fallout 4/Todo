Optimizations
	Define class attributes with a __slots__ list
	Store statement type as an attribute and check that instead of using isinstance()
	Get an attribute once and store the result when compared more than once
	Reduce use of chained dot operators (a.b.c.d.e.f vs a.c.e.f) when possible
		Generate e.g. StateSignature, but copy attribute values to State upon initialization (State.signature.identifier -> State.identifier)
	Remove or comment out lines ending with "#Prune" (mostly "assert" statements to enforce types of parameters in class constructors)

Mapping type identifiers to a path?
	Pass Type object to function
		Checks if already figured out
			Returns 

SEM encounters Type
	Validate Type
		Name only
			/import/path/name.psc
			/import/path/importednamespace/name.psc
			/import/path/importedscript.psc:name
			else does not exist
		Namespace and name
			/import/path/namespace/name.psc
			/import/path/importednamespace/namespace/name.psc
			/import/path/namespaceN-1/namespaceN.psc:name
			/import/path/importednamespace/namespaceN-1/namespaceN.psc:name
			else does not exist


Encounter type
	Get the script
		Get it from cache
			or
		Look for it using imported scripts and namespaces as help, if necessary
			Find it
				Cache it in the script's TypeMap cache under two keys: the identifier originally found and the full identifier, if it differs from the original identifier
			Don't find it
				Raise exception



Cache ideas
	Scripts
		- Files that have been processed into Script objects
		- Reside in a variable in Linter.py
		- Dict of Script with

			":".join(script.identifier.namespace[:].append(script.identifier.name)).upper()

		  as the key
		- Files only need to be turned into Script objects once (or after a cache invalidation, which would be after a manual command or after saving the file)

	LocalTypeMap
		- Resides in each Script object
		- Dict of 
		- Populated by ValidateScript function as types (scripts or structs) are used in the script that is being validated

	TypeMap
		- Figure out the path to a script file
		- Reside in a variable in Linter.py
		- Dict of str (absolute path to script file) with

			":".join(script.identifier.namespace[:].append(script.identifier.name)).upper()

		  as the key
		- The path to script files would only have to be determined once (or after a manual cache invalidation)

	StructMap
		- Figure out the script that contains a specific struct
		- Reside in a variable in Linter.py
		- Dict of str (key to use in Scripts cache) with

			":".join(script.identifier.namespace[:].append(script.identifier.name)).upper()

		  as the key

Overview
	Phase 1
		Line by line
			String -> Lexical -> Tokens
			Tokens -> Syntactic -> Statement
			Statement -> Semantic -> Assemble scope object
		Generate script object from scope objects

	Phase 2
		Validate script object and its scope objects

In more detail
	Phase 1 (performed on all scripts that are processed)
		Lexical analysis
			Verify valid horizontal groupings of all characters and generate Tokens

		Syntactic analysis
			Verify valid horizontal groupings of all Tokens and generate Statements
			Build list of other scripts to process from the types used:
				imports
					scripts (corresponding .psc file exists among import paths)
					namespaces (corresponding directory exists among import paths)
						add all scripts from the namespace to the list
				variable declarations
				property declarations
				struct member declarations
				group member declarations
				function parameter declarations
				event parameter declarations
				foreach element declarations
				parent script

		Semantic analysis
			Verify that vertical groupings of all Statements and generate Script

		Process all of the scripts and cache the results so that scripts are only processed once

	Phase 2 (performed only on the script that initiated the linting process aka the script being edited)
		Semantic analysis
			Verify validity of all statements and expressions in the context of all relevant scripts

Lexical objects
	Token
		.type
			TokenEnum member
		.value
			String
		.line
			Int
		.column
			Int

Syntactic objects
	Type
		.identifier
			Identifier
		.isArray
			Bool
		.isStruct
			Bool

	Identifier
		.namespace
			List of String
		.name
			String

	FunctionSignature
		.identifier
			Identifier
		.returnType
			Type
		.parameters
			List of FunctionParameter

	FunctionParameter
		.identifier
			Identifier
		.type
			Type
		.defaultValue
			Expression

	EventSignature
		.identifier
			Identifier
		.parameters
			List of EventParameter

	EventParameter
		.identifier
			Identifier
		.type
			Type

	GroupSignature
		.identifier
			Identifier
		.members
			Dict of Property

	PropertySignature
		.identifier
			Identifier
		.type
			Type
		.flags
			List of TokenEnum members
		.value
			Expression

	ScriptSignature
		.identifier
			Identifier
		.extends
			Identifier
		.flags
			List of TokenEnum members
				or
			ScriptFlags
				.default
					Bool
				.native
					Bool
				etc.

	StateSignature
		.identifier
			Identifier
		.auto
			Bool

	StructSignature
		.identifier
			Identifier


	Assignment
	CustomEvent
	Docstring
	Else
	ElseIf
	Expression
	If
	Import
	Parameter
	Return
	Variable declaration
	While
	Break
	Continue
	Switch
	Case
	Default
	For
	Foreach
	Do
	Loopwhile

	EndEvent
	EndFunction
	EndGroup
	EndIf
	EndProperty
	EndState
	EndStruct
	EndWhile
	EndFor
	EndForEach
	Endswitch


Semantic objects
	Script
		.signature
			ScriptSignature
		.imports
			Dict of Import
		.customEvents
			Dict of CustomEvent
		.variables
			Dict of Variable
		.properties
			Dict of Property
		.groups
			Dict of Group
		.functions
			Dict of Function
		.events
			Dict of Event
		.states
			Dict of State
		.structs
			Dict of Struct

	CustomEvent
		.identifier
			Identifier

	Variable
		.identifier
			Identifier
		.type
			Type
		.flags
			List of TokenEnum
		.line
			Int

	Property
		.identifier
			Identifier
		.type
			Type
		.flags
			List of TokenEnum members
		.starts
			Int
		.ends
			Int

	Group
		.members
			Dict of Property
		.starts
			Int
		.ends
			Int

	State
		.signature
			StateSignature
		.functions
			Dict of Function
		.events
			Dict of Event
		.starts
			Int
		.ends
			Int

	Struct
		.identifier
			Identifier
		.members
			Dict of Variable (Can struct members have a default value other than 0, 0.0, None, False, or ""?)
				or
			Dict of StructMember
				.identifier
					Identifier
				.type
					Type





















Caprica

Seprate syntax highlighting file that invokes the linter with Caprica extensions enabled

	Op-equals operations (+=, -=, etc.) on array elements are allowed.

	Integer literals can be used as the default value for floats, so no more .0 on the end of those literals.

	Local variables can be declared as Auto and their type will be inferred from the initializer expression.

	Break/Continue statements with the same semantics as are present in C++, are allowed.

	Switch-Case statements on Int and String values are allowed. Case values must be literals.

	ForEach statements can be used to iterate over an array or Collection.

	For statements can be used.

	Do-LoopWhile statements can be used.


For

The statement whose absence has most annoyed Papyrus users working with arrays. Fear not, for your cries have been heard, and your calls answered! The behaviour of it is the same as in VB.Net with the difference that <identifier> will never implicitly be defined. If you want to declare it as a variable, you must prefix it with a type.

	<for> ::= 'For' ['Int'|'Float'|'Auto'] <identifier> '=' <expression> 'To' <expression> ['Step' <expression>]
    	        <statement>*
        	  'EndFor'


ForEach

The ForEach statement may be used to iterate over arrays or collections. A collection is defined as any Object which implements a method named either GetCount or GetSize that accepts no parameters and returns an Int, and also implements a method named GetAt which accepts a single Int argument and returns the value at that index. <expression> is evaluated exactly once before the loop begins. FormList and RefCollectionAlias are two examples of objects in Fallout 4 that are considered collections.

	<foreach> ::= 'ForEach' (<type>|'Auto') <identifier> 'In' <expression>
    	            <statement>*
        	      'EndForEach'


Switch

The Switch statement may only be used on an Int or String, and the case values must be literals.

	<switch> ::= 'Switch' <expression>
    	           ['Case' (<integer>|<string>)
        	         <statement>*]*
            	   ['Default'
                 <statement>*]
         	    'EndSwitch'


Do-LoopWhile

The Do-LoopWhile statement is the same as a While statement, with the difference that the body is alway executed at least once.

	<do-loop-while> ::= 'Do'
    	                  <statement>*
        	            'LoopWhile' <expression>


Break/Continue

Break and Continue statements are both also supported as part of extensions to the language. Break will cause control to transfer after the innermost Switch, For, ForEach, Do-LoopWhile, or While statement containing the Break statement. Continue will cause control to tranfer to the next iteration of the innermost For, ForEach, Do-LoopWhile, or While statement containing the Continue statement.

	<break> ::= 'Break'
	<continue> ::= 'Continue'






	kBREAK
	kCONTINUE
	kDEFAULT
	kSWITCH
	kENDSWITCH
	kCASE
	kFOREACH
	kENDFOREACH
	kFOR
	kENDFOR
	kDO
	kLOOPWHILE
	kTO

	BREAK
	CONTINUE

	SWITCH
	CASE
	DEFAULT
	ENDSWITCH

	FOR TO
	ENDFOR

	FOREACH IN
	ENDFOREACH

	DO
	LOOPWHILE