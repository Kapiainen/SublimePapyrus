Optimizations
	Define class attributes with a __slots__ list
	Store statement type as an attribute and check that instead of using isinstance()
	Get an attribute once and store the result when compared more than once
	Reduce use of chained dot operators (a.b.c.d.e.f vs a.c.e.f) when possible
		Generate e.g. StateSignature, but copy attribute values to State upon initialization (State.signature.identifier -> State.identifier)

Mapping type identifiers to a path?
	Pass Type object to function
		Checks if already figured out
			Returns 

SEM encounters Type
	Validate Type
		Name only
			/import/path/name.psc
			/import/path/importednamespace/name.psc
			/import/path/importedscript.psc:name
			else does not exist
		Namespace and name
			/import/path/namespace/name.psc
			/import/path/importednamespace/namespace/name.psc
			/import/path/namespaceN-1/namespaceN.psc:name
			/import/path/importednamespace/namespaceN-1/namespaceN.psc:name
			else does not exist

Phase 1
	Line by line
		String -> Lexical -> Tokens
		Tokens -> Syntactic -> Statement
		Statement -> Semantic -> Assemble scope object
	Generate script object from scope objects

Phase 2
	Validate script object and its scope objects

Lexical objects
	Token
		.type
			TokenEnum member
		.value
			String
		.line
			Int
		.column
			Int

Syntactic objects
	Type
		.identifier
			Identifier
		.isArray
			Bool
		.isStruct
			Bool

	Identifier
		.namespace
			List of String
		.name
			String

	FunctionSignature
		.identifier
			Identifier
		.returnType
			Type
		.parameters
			List of FunctionParameter

	FunctionParameter
		.identifier
			Identifier
		.type
			Type
		.defaultValue
			Expression

	EventSignature
		.identifier
			Identifier
		.parameters
			List of EventParameter

	EventParameter
		.identifier
			Identifier
		.type
			Type

	GroupSignature
		.identifier
			Identifier
		.members
			Dict of Property

	PropertySignature
		.identifier
			Identifier
		.type
			Type
		.flags
			List of TokenEnum members
		.value
			Expression

	ScriptSignature
		.identifier
			Identifier
		.extends
			Identifier
		.flags
			List of TokenEnum members
				or
			ScriptFlags
				.default
					Bool
				.native
					Bool
				etc.

	StateSignature
		.identifier
			Identifier
		.auto
			Bool

	StructSignature
		.identifier
			Identifier


	Assignment
	CustomEvent
	Docstring
	Else
	ElseIf
	Expression
	If
	Import
	Parameter
	Return
	Variable declaration
	While
	Break
	Continue
	Switch
	Case
	Default
	For
	Foreach
	Do
	Loopwhile

	EndEvent
	EndFunction
	EndGroup
	EndIf
	EndProperty
	EndState
	EndStruct
	EndWhile
	EndFor
	EndForEach
	Endswitch


Semantic objects
	Script
		.signature
			ScriptSignature
		.imports
			Dict of Import
		.customEvents
			Dict of CustomEvent
		.variables
			Dict of Variable
		.properties
			Dict of Property
		.groups
			Dict of Group
		.functions
			Dict of Function
		.events
			Dict of Event
		.states
			Dict of State
		.structs
			Dict of Struct

	CustomEvent
		.identifier
			Identifier

	Variable
		.identifier
			Identifier
		.type
			Type
		.flags
			List of TokenEnum
		.line
			Int

	Property
		.identifier
			Identifier
		.type
			Type
		.flags
			List of TokenEnum members
		.starts
			Int
		.ends
			Int

	Group
		.members
			Dict of Property
		.starts
			Int
		.ends
			Int

	State
		.signature
			StateSignature
		.functions
			Dict of Function
		.events
			Dict of Event
		.starts
			Int
		.ends
			Int

	Struct
		.identifier
			Identifier
		.members
			Dict of Variable (Can struct members have a default value other than 0, 0.0, None, False, or ""?)
				or
			Dict of StructMember
				.identifier
					Identifier
				.type
					Type





















Caprica

Seprate syntax highlighting file that invokes the linter with Caprica extensions enabled

	Op-equals operations (+=, -=, etc.) on array elements are allowed.

	Integer literals can be used as the default value for floats, so no more .0 on the end of those literals.

	Local variables can be declared as Auto and their type will be inferred from the initializer expression.

	Break/Continue statements with the same semantics as are present in C++, are allowed.

	Switch-Case statements on Int and String values are allowed. Case values must be literals.

	ForEach statements can be used to iterate over an array or Collection.

	For statements can be used.

	Do-LoopWhile statements can be used.

	kBREAK
	kCONTINUE
	kDEFAULT
	kSWITCH
	kENDSWITCH
	kCASE
	kFOREACH
	kENDFOREACH
	kFOR
	kENDFOR
	kDO
	kLOOPWHILE
	kTO

	BREAK
	CONTINUE

	SWITCH
	CASE
	DEFAULT
	ENDSWITCH

	FOR TO
	ENDFOR

	FOREACH IN
	ENDFOREACH

	DO
	LOOPWHILE